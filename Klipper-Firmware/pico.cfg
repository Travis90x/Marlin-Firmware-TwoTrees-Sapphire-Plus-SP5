# This file contains an example configuration with RP2040 as secondary mcu
# See docs/Config_Reference.md for a description of parameters.
# The rpi microcontroller is used as secondary.
# Typically, both the X and Y axes are connected to the main micro-controller. 
# The rpi microcontroller is used on non time-critical functions such as enclosure sensors, additional fan or light sources

[include shell_command.cfg]  # to run scripts .sh
# from this github TwoTrees-Sapphire-Plus-SP5/Klipper-Firmware/scripts
# copy in /home/pi/klipper/scripts/ these scripts:
# generate-belt-tension-graph.sh
# generate-shaper-graph-x.sh
# generate-shaper-graph-y.sh 
# or give them from https://github.com/Rat-OS/RatOS-configuration/blob/master/scripts/

# [mcu rpi]  # This is for Klipper running on Raspberry
# serial: /tmp/klipper_host_mcu


# The "rp2040" micro-controller will be used to control the accelerometer.
[mcu RP2040]
  serial: /dev/serial/by-id/usb-Klipper_rp2040_E66138935F225928-if00   #check your usb ID
    #to find correct usb serial XXXXXXXXXXXX, type in terminal: ls /dev/serial/by-id/*
  baud: 115200  # 250000
  restart_method: command
# restart_method: rpi_usb


[adxl345]  # connected to RP4020
  spi_bus: spi0a
  cs_pin: RP2040:gpio1
# axes_map: x,z,y  # if the axys in different from adxl correct mount


# [adxl345_2]   # add a second ADXL on RP4020
# spi_bus: spi0b
# cs_pin: RP2040:gpio5

# ROBIN Nano   # ADXL connected directly on Robin Nano V1.2 SDcard pinout - without RP4020
# [adxl345]
# cs_pin: PC8
# spi_software_miso_pin: PC9
# spi_software_sclk_pin: PC10
# spi_software_mosi_pin: PC11

############ INPUT SHAPER ############

[input_shaper]
    shaper_freq_x: 57.6   # edit these values after check results of tests
    shaper_freq_y: 44.2
    shaper_type_x: ei
    shaper_type_y: mzv


############ TESTS ############

[resonance_tester]
  accel_chip: adxl345
  probe_points: 
    150, 150, 20  # an example of the center of the toolhead
    
    
[gcode_macro Resonance]
gcode:
    ACCELEROMETER_QUERY
    G28
    TEST_RESONANCES AXIS=X
    G4 P1000
    TEST_RESONANCES AXIS=Y
    G4 P1000
    RUN_SHELL_COMMAND CMD=shaper_calibrate_x
    G4 P10000
    RUN_SHELL_COMMAND CMD=shaper_calibrate_y


[gcode_macro Res_Belt]
gcode:
    ACCELEROMETER_QUERY
    G28
    TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data
    G4 P1000
    TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data
    G4 P1000
    RUN_SHELL_COMMAND CMD=belt-tension


######## NEOPIXEL ########

# [output_pin pico_led]
# pin: RP2040:gpio16
# pwm: True
# cycle_time: 0.100
# hardware_pwm: True
# value: 1
# shutdown_value: 0


[include progress.cfg]

[neopixel pico_led]
  pin: RP2040:gpio16
  chain_count:   2 #how many led
  color_order: RGB
  initial_RED: 0.0
  initial_BLUE: 0.0
  initial_GREEN: 0.0

[gcode_macro neo_t]
  gcode:
    NEOPIXEL_DISPLAY LED="pico_led" TYPE=extruder_temp MODE=glow

[gcode_macro neo_%]
  gcode:
    NEOPIXEL_DISPLAY LED="pico_led" TYPE=print_percent MODE=progress
# This macro command will show print completion in progress mode.

[gcode_macro neo_bar]
  gcode:
    NEOPIXEL_DISPLAY LED="pico_led" TYPE=print_speed MODE=progress


# cycle_time: 0.010
# cycle_time: 0.100
#   The amount of time (in seconds) per PWM cycle. It is recommended
#   this be 10 milliseconds or greater when using software based PWM.
#   The default is 0.100 seconds for pwm pins.

#hardware_pwm: False
#   Enable this to use hardware PWM instead of software PWM. When
#   using hardware PWM the actual cycle time is constrained by the
#   implementation and may be significantly different than the
#   requested cycle_time. The default is False.


# [led_effect panel_idle]
# autostart:              true
# frame_rate:             24
# leds:
    # neopixel:pico_led
# layers:
    # breathing  10 1 top (.5,.5,1)


# [gcode_macro blink_led]
  # description: Blink my_led one time
  # gcode:
    # SET_PIN PIN=pico_led VALUE=1  # If unknown commad, it needs  [output_pin XXX] config section  enabled
    # G4 P2000
    # SET_PIN PIN=pico_led VALUE=0

# [gcode_macro LEDOFF]
  # gcode:
    # SET_PIN PIN=pico_led VALUE=0

# [gcode_macro LEDMIN]
#  gcode:
    # # SET_PIN PIN=pico_led VALUE=.5

# [gcode_macro LEDMAX]
  # gcode:
    # SET_PIN PIN=pico_led VALUE=1


# [mcu host]
# serial: /tmp/klipper_host_mcu

# Example1: A led strip controlled by the GPIO20 on the RPi
# [output_pin caselight]
# pin: host:gpio20
# You can also write the pin in extended form by specifying
# the reference gpiochip.
# pin: host:gpiochip0/gpio20

# [gcode_macro TOGGLE_CASELIGHT]
# gcode:
#    SET_PIN PIN=caselight VALUE={(not printer['output_pin caselight'].value)|int}


# Example2: Using the i2c bus of the RPi to read a sensor
# [temperature_sensor enclosure_temp]
# sensor_type: HTU21D
# i2c_mcu: host
# i2c_bus: i2c.1
# htu21d_hold_master: False

# [gcode_macro QUERY_ENCLOSURE]
# gcode:
#  {% set sensor = printer["htu21d enclosure_temp"] %}
# {action_respond_info(
#    "Temperature: %.2f C\n"
#     "Humidity: %.2f%%" % (
#            sensor.temperature,
#            sensor.humidity))}

# Example 3:Using a pin on another gpiochip connected to the RPi
# (in this case on an MCP23017)
# [fan]
# pin: host:gpiochip2/gpio7
