# This file contains an example configuration with RPi as secondary mcu

# See docs/Config_Reference.md for a description of parameters.

# The rpi microcontroller is used as secondary.
# Typically, both the X and Y axes
# are connected to the main micro-controller. The rpi microcontroller is used
# on non time-critical functions such as enclosure sensors, additional fan or
# light sources


# [mcu rpi]
# serial: /tmp/klipper_host_mcu


# The "rp2040" micro-controller will be used to control the accelerometer.
# [mcu rp2040]
# serial: /dev/serial/by-id/usb-1a86_USB_Serial-if00-port1


[input_shaper]
    shaper_freq_x: 62.8
    shaper_freq_y: 45.8
    shaper_type_x: ei
    shaper_type_y: mzv

##  Damping ratios of vibrations of X and Y axes used by input shapers
##  to improve vibration suppression. Default value is 0.1 which is a
##  good all-round value for most printers. In most circumstances this
##  parameter requires no tuning and should not be changed.
#damping_ratio_x: 0.1
#damping_ratio_y: 0.1



[mcu RP2040]
  serial: /dev/serial/by-id/usb-Klipper_rp2040_E66138935F225928-if00
  baud: 115200  # 250000
  restart_method: command
# restart_method: rpi_usb

[adxl345]
  spi_bus: spi0a
  cs_pin: RP2040:gpio1
# axes_map: x,z,y

[resonance_tester]
  accel_chip: adxl345
  probe_points: 
    150, 150, 20  # an example

# [adxl345_2]
# spi_bus: spi0b
# cs_pin: RP2040:gpio5

# ROBIN Nano
# [adxl345]
# cs_pin: PC8
# spi_software_miso_pin: PC9
# spi_software_sclk_pin: PC10
# spi_software_mosi_pin: PC11
# axes_map: x,z,y



# This need for skip the first read error on ADXL345
[delayed_gcode _Resonance]
initial_duration: 1.0
gcode:
    ACCELEROMETER_QUERY

[gcode_macro Res_XY]
gcode:
    ACCELEROMETER_QUERY
    G28
    TEST_RESONANCES AXIS=X
    G4 P5000
    TEST_RESONANCES AXIS=Y
    G4 P5000   # time needed to write the file before start script
    RUN_SHELL_COMMAND CMD=shaper_calibrate_x
    G4 P5000
    RUN_SHELL_COMMAND CMD=shaper_calibrate_y


[gcode_macro Res_Belt]
gcode:
    ACCELEROMETER_QUERY
    G28
    TEST_RESONANCES AXIS=1,1 OUTPUT=raw_data
    G4 P5000
    TEST_RESONANCES AXIS=1,-1 OUTPUT=raw_data
    G4 P5000
    RUN_SHELL_COMMAND CMD=belt-tension




# [output_pin pico_led]
# pin: RP2040:gpio16
# pwm: True
# cycle_time: 0.100
# hardware_pwm: True
# value: 1
# shutdown_value: 0


[include progress.cfg]

[neopixel pico_led]
  pin: RP2040:gpio16
  chain_count:   2 #how many led
  color_order: RGB
  initial_RED: 0.0
  initial_BLUE: 0.0
  initial_GREEN: 0.0

[gcode_macro neo_t]
  gcode:
    NEOPIXEL_DISPLAY LED="pico_led" TYPE=extruder_temp MODE=glow

[gcode_macro neo_%]
  gcode:
    NEOPIXEL_DISPLAY LED="pico_led" TYPE=print_percent MODE=progress
# This macro command will show print completion in progress mode.

[gcode_macro neo_bar]
  gcode:
    NEOPIXEL_DISPLAY LED="pico_led" TYPE=print_speed MODE=progress






# cycle_time: 0.010
# cycle_time: 0.100
#   The amount of time (in seconds) per PWM cycle. It is recommended
#   this be 10 milliseconds or greater when using software based PWM.
#   The default is 0.100 seconds for pwm pins.

#hardware_pwm: False
#   Enable this to use hardware PWM instead of software PWM. When
#   using hardware PWM the actual cycle time is constrained by the
#   implementation and may be significantly different than the
#   requested cycle_time. The default is False.


# [led_effect panel_idle]
# autostart:              true
# frame_rate:             24
# leds:
    # neopixel:pico_led
# layers:
    # breathing  10 1 top (.5,.5,1)


# [gcode_macro blink_led]
  # description: Blink my_led one time
  # gcode:
    # SET_PIN PIN=pico_led VALUE=1  # If unknown commad, it needs  [output_pin XXX] config section  enabled
    # G4 P2000
    # SET_PIN PIN=pico_led VALUE=0

# [gcode_macro LEDOFF]
  # gcode:
    # SET_PIN PIN=pico_led VALUE=0

# [gcode_macro LEDMIN]
#  gcode:
    # # SET_PIN PIN=pico_led VALUE=.5

# [gcode_macro LEDMAX]
  # gcode:
    # SET_PIN PIN=pico_led VALUE=1


# [mcu host]
# serial: /tmp/klipper_host_mcu

# Example1: A led strip controlled by the GPIO20 on the RPi
# [output_pin caselight]
# pin: host:gpio20
# You can also write the pin in extended form by specifying
# the reference gpiochip.
# pin: host:gpiochip0/gpio20

# [gcode_macro TOGGLE_CASELIGHT]
# gcode:
#    SET_PIN PIN=caselight VALUE={(not printer['output_pin caselight'].value)|int}


# Example2: Using the i2c bus of the RPi to read a sensor
# [temperature_sensor enclosure_temp]
# sensor_type: HTU21D
# i2c_mcu: host
# i2c_bus: i2c.1
# htu21d_hold_master: False

# [gcode_macro QUERY_ENCLOSURE]
# gcode:
#  {% set sensor = printer["htu21d enclosure_temp"] %}
# {action_respond_info(
#    "Temperature: %.2f C\n"
#     "Humidity: %.2f%%" % (
#            sensor.temperature,
#            sensor.humidity))}

# Example 3:Using a pin on another gpiochip connected to the RPi
# (in this case on an MCP23017)
# [fan]
# pin: host:gpiochip2/gpio7
